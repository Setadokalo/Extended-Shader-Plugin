[gd_scene load_steps=14 format=2]

[ext_resource path="res://MainMenu.gd" type="Script" id=1]
[ext_resource path="res://addons/sisilicon.shaders.extended-shader/Hack_Regular.ttf" type="DynamicFontData" id=2]
[ext_resource path="res://addons/sisilicon.shaders.extended-shader/ExtendedShader.gd" type="Script" id=3]

[sub_resource type="Shader" id=1]
code = "/**** INCLUDED FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/
shader_type canvas_item;
/**** END OF INCLUDE FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/

/**** INCLUDED FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/noise/classic_perlin3d.extshader\" ****/
/**** INCLUDED FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/
/**** END OF INCLUDE FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/


// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

/**** INCLUDED FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/noise/mathlib.extshader\" ****/
/**** INCLUDED FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/
/**** END OF INCLUDE FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/canvas_hedr.extshader\" ****/

const float INV_289 = 1.0 / 289.0;
const float INV_7 = 1.0 / 7.0;

// Modulo 289 without a division (only multiplications)
vec4 mod289_4(vec4 x) {
  return x - floor(x * INV_289) * 289.0;
}

vec3 mod289_3(vec3 x) {
    return x - floor(x * INV_289) * 289.0;
}

vec2 mod289_2(vec2 x) {
    return x - floor(x * INV_289) * 289.0;
}

float mod289(float x) {
    return x - floor(x * INV_289) * 289.0;
}

// Modulo 7 without a division
vec3 mod7_3(vec3 x) {
    return x - floor(x * INV_7) * 7.0;
}

vec4 mod7_4(vec4 x) {
  return x - floor(x * INV_7) * 7.0;
}

float permute(float x) {
    return mod289(((x * 34.0) + 1.0) * x);
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 permute_3(vec3 x) {
    return mod289_3((34.0 * x + 1.0) * x);
}

// Permutation polynomial: (34x^2 + x) mod 289
vec4 permute_4(vec4 x) {
  return mod289_4((34.0 * x + 1.0) * x);
}

vec4 taylorInvSqrt_4(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

float taylorInvSqrt(float r) {
    return 2.79284291400159 - 1.85373472095314 * r;
}

vec2 fade_2(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

vec3 fade_3(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

vec4 fade_4(vec4 t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

/**** END OF INCLUDE FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/noise/mathlib.extshader\" ****/

// Classic Perlin noise
float cnoise3d(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute_4(permute_4(ix) + iy);
    vec4 ixy0 = permute_4(ixy + iz0);
    vec4 ixy1 = permute_4(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt_4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt_4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade_3(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 2.2 * n_xyz;
}

// Classic Perlin noise, periodic variant
float pnoise_3(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute_4(permute_4(ix) + iy);
    vec4 ixy0 = permute_4(ixy + iz0);
    vec4 ixy1 = permute_4(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt_4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt_4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade_3(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 2.2 * n_xyz;
}

/**** END OF INCLUDE FROM  \"res://addons/sisilicon.shaders.extended-shader/builtin_shaders/noise/classic_perlin3d.extshader\" ****/

varying vec2 pos;

void vertex() {
	pos = VERTEX;
}

void fragment() {
	COLOR.r = cnoise3d(vec3(pos/80.0 - TIME/4.0, TIME / 3.0)) * 0.5 + 0.5;
	COLOR.g = cnoise3d(vec3(pos/80.0 + TIME/4.0, TIME / 3.0 + 4000.0)) * 0.5 + 0.5;
	COLOR.b = cnoise3d(vec3(pos/80.0 + TIME/4.0, TIME / 3.0 + 4000.0));
	COLOR.rgb *= 0.75;
}
"
script = ExtResource( 3 )
defines = {
}
raw_code = "#include <\"canvas_hedr\">

#include <\"noise/classic_perlin3d\">

varying vec2 pos;

void vertex() {
	pos = VERTEX;
}

void fragment() {
	COLOR.r = cnoise3d(vec3(pos/80.0 - TIME/4.0, TIME / 3.0)) * 0.5 + 0.5;
	COLOR.g = cnoise3d(vec3(pos/80.0 + TIME/4.0, TIME / 3.0 + 4000.0)) * 0.5 + 0.5;
	COLOR.b = cnoise3d(vec3(pos/80.0 + TIME/4.0, TIME / 3.0 + 4000.0));
	COLOR.rgb *= 0.75;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )

[sub_resource type="StyleBoxFlat" id=3]
bg_color = Color( 0.172549, 0.172549, 0.172549, 1 )
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color( 0.529412, 0.529412, 0.529412, 1 )
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id=4]
bg_color = Color( 0.258824, 0.258824, 0.258824, 1 )
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color( 0.529412, 0.529412, 0.529412, 1 )
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id=5]
bg_color = Color( 0.0745098, 0.0745098, 0.0745098, 1 )
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color( 0.529412, 0.529412, 0.529412, 1 )
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="Theme" id=6]
Button/colors/font_color = Color( 0.88, 0.88, 0.88, 1 )
Button/colors/font_color_disabled = Color( 0.9, 0.9, 0.9, 0.2 )
Button/colors/font_color_hover = Color( 0.94, 0.94, 0.94, 1 )
Button/colors/font_color_pressed = Color( 1, 1, 1, 1 )
Button/constants/hseparation = 2
Button/fonts/font = null
Button/styles/disabled = null
Button/styles/focus = SubResource( 3 )
Button/styles/hover = SubResource( 4 )
Button/styles/normal = SubResource( 3 )
Button/styles/pressed = SubResource( 5 )

[sub_resource type="DynamicFont" id=7]
size = 20
font_data = ExtResource( 2 )

[sub_resource type="StyleBoxFlat" id=8]
bg_color = Color( 0.156863, 0.156863, 0.156863, 0.643137 )
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="DynamicFontData" id=9]
font_path = "res://addons/sisilicon.shaders.extended-shader/Hack_Regular.ttf"

[sub_resource type="DynamicFont" id=10]
size = 48
outline_size = 3
outline_color = Color( 1, 0.690196, 0.309804, 1 )
use_mipmaps = true
use_filter = true
extra_spacing_top = -1
extra_spacing_bottom = -1
extra_spacing_char = 2
font_data = SubResource( 9 )

[node name="Control" type="Panel"]
material = SubResource( 2 )
anchor_right = 1.0
anchor_bottom = 1.0
script = ExtResource( 1 )

[node name="HBoxContainer" type="HBoxContainer" parent="."]
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
margin_left = -300.0
margin_top = -50.0
margin_right = 300.0
margin_bottom = 50.0
grow_horizontal = 2
grow_vertical = 2
theme = SubResource( 6 )
custom_constants/separation = 70
__meta__ = {
"_edit_use_anchors_": false
}

[node name="TextEditTest" type="Button" parent="HBoxContainer"]
margin_right = 265.0
margin_bottom = 100.0
size_flags_horizontal = 3
size_flags_vertical = 3
custom_fonts/font = SubResource( 7 )
text = "Text Edit Test"

[node name="TokenParseTest" type="Button" parent="HBoxContainer"]
margin_left = 335.0
margin_right = 600.0
margin_bottom = 100.0
size_flags_horizontal = 3
size_flags_vertical = 3
custom_fonts/font = SubResource( 7 )
text = "Tokenizer/Parser Test"

[node name="Panel" type="Panel" parent="."]
anchor_left = 0.5
anchor_right = 0.5
margin_left = -350.0
margin_top = 12.0
margin_right = 350.0
margin_bottom = 112.0
custom_styles/panel = SubResource( 8 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Panel"]
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
custom_fonts/font = SubResource( 10 )
custom_colors/font_color = Color( 1, 0.988235, 0.917647, 1 )
text = "Extended Shader Tests"
align = 1
valign = 1
__meta__ = {
"_edit_use_anchors_": false
}

[connection signal="pressed" from="HBoxContainer/TextEditTest" to="." method="_on_TextEditTest_pressed"]
[connection signal="pressed" from="HBoxContainer/TokenParseTest" to="." method="_on_TokenParseTest_pressed"]
